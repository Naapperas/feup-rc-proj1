\documentclass[11pt,a4paper,twocolumn]{article}

\usepackage[margin=.75in]{geometry}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage[super]{nth}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.18}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orange}{rgb}{.7,.3,0}

\makeatletter
\lst@InstallKeywords k{types}{typestyle}\slshape{typestyle}{}ld
\makeatother

\lstset{
    language=c,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    basicstyle={\small\ttfamily},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    typestyle=\color{orange},
    breaklines=true,
    breakatwhitespace=true,
    moretypes={
        LLConnection, LLConnectionParams, LLRole, Frame, ByteVector,
        uint8_t, size_t, ssize_t, bool, termios, timer_t
    }
}

\title{RC - \nth{1} Project}
\author{Jo√£o Pereira, Nuno Pereira}

\begin{document}

\maketitle

% \begin{abstract}
%     TODO
% \end{abstract}

% \pagebreak

% \tableofcontents

% \pagebreak

\section{Introduction}

The objective of this project was to develop a simple data link layer and an application to test the effectiveness of this layer.

\section{Architecture}

\subsection{Layers}

The code was divided into two distinct layers. This has the advantage of making the code more modular, reusable and versatile, as either layer could be swapped for another with a similar interface with minimal effort.

\subsubsection{Data Link Layer}

This is the lower level layer, it interfaces with the serial port driver directly. It is responsible for ensuring the data gets sent and received.

\subsubsection{Application Layer}

This is the higher level layer, it interfaces with the data link layer and with the file system. It is responsible for reading a file, breaking it up into chunks, sending these chunks through the data link layer, receiving these chunks, and assembling them back into a file.

\subsection{Program Execution}

The program can be executed by calling \lstinline{app serial_port role file_name}, where:

\begin{itemize}
    \item \lstinline{app} is the program executable;
    \item \lstinline{serial_port} is the serial port file path;
    \item \lstinline{role} is one of \lstinline{rx|tx}, for receiving or transmitting a file, respectively;
    \item \lstinline{file_name} is the path of the file to be sent.
\end{itemize}

\section{Code Structure}

\subsection{Data Link Layer}
\label{sec:dll}

The Data Link Layer is centered on the \lstinline{link_layer.c} file and the \lstinline{link_layer} folder.
The \lstinline{link_layer.c} file contains the protocol interface that can be used by upper layers, the \lstinline{timer.c} file contains code related to interfacing with POSIX timers, and the \lstinline{frame.c} file contains code to create and manipulate frames.

\subsubsection{link\_layer.c}

\begin{itemize}
    \item \begin{lstlisting}
typedef enum { LL_TX, LL_RX } LLRole;
    \end{lstlisting}

          Defines the role of a link layer connection.

    \item \begin{lstlisting}
typedef struct {
    char serial_port[50];
    LLRole role;
    int baud_rate;
    int n_retransmissions;
    int timeout;
} LLConnectionParams;
    \end{lstlisting}

          Defines the parameters required to create a new link layer connection.

    \item \begin{lstlisting}
struct _LLConnection {
    LLConnectionParams params;
    struct termios old_termios;
    int fd;
    bool closed;
    uint8_t tx_sequence_nr;
    uint8_t rx_sequence_nr;
    int n_retransmissions_sent;
    timer_t timer;
    Frame *last_command_frame;
};
    \end{lstlisting}

          Defines the state of a link layer connection.

    \item \begin{lstlisting}
LLConnection *llopen(
    LLConnectionParams params);
    \end{lstlisting}

          Opens a new link layer connection and returns it.

    \item \begin{lstlisting}
ssize_t llwrite(
    LLConnection *connection,
    const uint8_t *buf,
    size_t buf_len);
    \end{lstlisting}

          Sends data through a connection.

    \item \begin{lstlisting}
ssize_t llread(
    LLConnection *connection, 
    uint8_t *buf);
    \end{lstlisting}

          Reads data from a connection.

    \item \begin{lstlisting}
int llclose(
    LLConnection *connection, 
    bool show_stats);
    \end{lstlisting}

          Closes a connection.
\end{itemize}

\subsubsection{link\_layer/timer.c}

\begin{itemize}
    \item \begin{lstlisting}
void timer_setup(
    LLConnection *connection);
    \end{lstlisting}

          Sets up a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_destroy(
    LLConnection *connection);
    \end{lstlisting}

          Deallocates a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_arm(
    LLConnection *connection);
    \end{lstlisting}

          Starts a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_disarm(
    LLConnection *connection);
    \end{lstlisting}

          Stops a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_force(
    LLConnection *connection);
    \end{lstlisting}

          Forcibly calls a connection's timer handler.

\end{itemize}

\subsubsection{link\_layer/frame.c}

\begin{itemize}
    \item \begin{lstlisting}
typedef struct {
    uint8_t address;
    uint8_t command;
    ByteVector *information;
} Frame;
    \end{lstlisting}

          Defines all the data needed to represent a frame.

    \item \begin{lstlisting}
Frame *create_frame(
    LLConnection *connection, 
    uint8_t cmd);
    \end{lstlisting}

          Creates a new frame.

    \item \begin{lstlisting}
Frame *read_frame(
    LLConnection *connection);
    \end{lstlisting}

          Reads a frame from the connection's serial port.

    \item \begin{lstlisting}
ssize_t write_frame(
    LLConnection *connection, 
    Frame *frame);
    \end{lstlisting}

          Writes a frame to the connection's serial port.

    \item \begin{lstlisting}
void frame_destroy(Frame *this);
    \end{lstlisting}

          Deallocates all memory allocated by a frame.

    \item \begin{lstlisting}
ssize_t send_frame(
    LLConnection *connection, 
    Frame *frame);
    \end{lstlisting}

          Sends a frame to the connection's serial port and sets up retransmission if the frame is a command.

    \item \begin{lstlisting}
Frame *expect_frame(
    LLConnection *connection, 
    uint8_t command);
    \end{lstlisting}

          Receives frames from a connection until a certain command is received.

\end{itemize}

\subsection{Application Layer}

The Application Layer is centered around the \lstinline{application_layer.c} file and the \lstinline{application_layer} folder.
The \lstinline{application_layer.c} file contains the client facing interface of the application which is responsible for all the higher level setup and communication between transmitter and receiver.
The \lstinline{packet.c} file contains code that is responsible for correctly creating control and data packets.

\subsubsection{application\_layer.c}

\begin{itemize}
    \item \begin{lstlisting}
LLConnectionParams setupLLParams(
    const char *serial_port, 
    const char *role, 
    int baud_rate, 
    int nTries, 
    int timeout);
    \end{lstlisting}

          Compiles the parameters given to the application layer into an \lstinline{LLConnectionParams} object to be used by the underlying \hyperref[sec:dll]{Data Link Layer}.

    \item \begin{lstlisting}
LLConnection *connect(
    LLConnectionParams ll);
    \end{lstlisting}

          Opens a connection to one of the computer's serial ports.

    \item \begin{lstlisting}
int init_transmission(
    LLConnection *connection, 
    char *filename);
    \end{lstlisting}

          Starts the communication process between transmitter and receiver.

    \item \begin{lstlisting}
ssize_t receiver(
    LLConnection *connection);
    \end{lstlisting}

          Executes the receiver's operational flow.

    \item \begin{lstlisting}
ssize_t transmitter(
    LLConnection *connection, 
    const char *filename);
    \end{lstlisting}

          Executes the transmitter's operational flow.

    \item \begin{lstlisting}
void applicationLayer(
    const char *serial_port, 
    const char *role, 
    int baud_rate, 
    int n_tries, 
    int timeout, 
    const char *filename);
    \end{lstlisting}

          Entrypoint for the application layer.

\end{itemize}

\subsubsection{application\_layer/packet.c}

\begin{itemize}
    \item \begin{lstlisting}
ByteVector *create_start_packet(
    size_t file_size, 
    const char *file_name);
    \end{lstlisting}

          Creates a \textbf{START} packet containing the transmitted file's size and name.

\end{itemize}

\section{Main Use Cases}

There are two main use cases: either sending a file or receiving a file.
These use cases are described below.

\subsection{Sending a file}

TODO

\subsection{Receiving a file}

TODO

\section{Link Layer Protocol}

The link layer protocol's flow is as follows: open a connection using \lstinline{llopen}, send arbitrary data using \lstinline{llwrite}, receive arbitrary data using \lstinline{llread}, and close the connection using \lstinline{llclose}.
Each step's implementation is described below.

This implementation uses an \lstinline{LLConnection} struct to save the state of a connection and in theory allows multiple serial port connections to be open in a single process.
In practice this was not required or tested.

\subsection{llopen}

\begin{lstlisting}
LLConnection *llopen(
    LLConnectionParams params);
\end{lstlisting}

This function opens a connection to the serial port and creates a new Data Link Layer connection object.

Firstly, this functions calls \lstinline{setup_serial} to setup the serial port connection, then it calls \lstinline{timer_setup} to setup a POSIX timer to handle timeouts when sending commands.
Afterwards, the implementation differs depending on the role of a connection.

From a transmitter's standpoint, a connection can only be considered \textbf{open} when a receiver is ready to receive data.
As so, this function implements a syncing procedure and sends a \textit{SET} command, which must get a \textit{UA} response in return.
If a response is not received, the command is resent a configurable amount of times, with an also configurable amount of time between them.

On the other hand, a receiver's connection can be considered open immediately, which means this syncing procedure is not handled by this function.

\subsection{llwrite}

\begin{lstlisting}
ssize_t llwrite(
    LLConnection *connection, 
    const uint8_t *buf, 
    size_t buf_len);
\end{lstlisting}

\subsection{llread}

\begin{lstlisting}
ssize_t llread(
    LLConnection *connection, 
    uint8_t *buf);
\end{lstlisting}

\subsection{llclose}

\begin{lstlisting}
int llclose(
    LLConnection *connection, 
    bool show_stats);
\end{lstlisting}

\section{Application Layer Protocol}

TODO

\section{Validation}

TODO

\section{Link Layer Efficiency}

TODO

\section{Conclusions}

TODO

\pagebreak
\onecolumn
\appendix
\section{Appendix}

\subsection{Code}

\noindent In folder \lstinline{code/}.

\subsection{Figures}

\pgfkeys{/pgf/number format/.cd,fixed,precision=4}
\pgfplotstableset{
    every head row/.style={before row=\hline},
    every last row/.style={after row=\hline},
    every column/.style={column type/.add={|}{}},
    every first column/.style={column type/.add={|}{}},
    every last column/.style={column type/.add={}{||}},
}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/C/.style={column name={Baud rate}},
        columns/FS/.style={column name={File size}},
        columns/PS/.style={column name={Packet size}},
        every first row/.style={
                before row={
                        \textit{bit/s} &
                        \textit{bit} &
                        \textit{byte} \\
                        \hline \hline}
            }
    ]{defaults.tsv}
    \caption{Default values}
\end{table}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/C/.style={column name={Baud rate}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        \textit{bit/s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{c.tsv}
    \caption{Efficiency for a varied baud rate}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as baud rate increases},
                xlabel={Baud rate (\textit{bit/s})},
                xmin=0, xmax=120000,
                ylabel={Efficiency},
                ymin=0.7, ymax=0.8
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=C, y=S] {c.tsv};
            \legend{S(FER, a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/FER/.style={column name={Frame error ratio}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{fer.tsv}
    \caption{Efficiency for a varied frame error ratio}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as frame error ratio increases},
                xlabel={Frame error ratio},
                xmin=0, xmax=.2,
                ylabel={Efficiency},
                ymin=0, ymax=1
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=FER, y=S] {fer.tsv};
            \legend{S(FER, a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/d/.style={column name={Cable length}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        \textit{km} &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{tprop.tsv}
    \caption{Efficiency for a varied cable length}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as cable length increases},
                xlabel={Cable length (\textit{km})},
                xmin=0, xmax=10000,
                ylabel={Efficiency},
                ymin=0.4, ymax=0.8
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=d, y=S] {tprop.tsv};
            \legend{S(FER, a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/PS/.style={column name={Packet size}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        \textit{byte} &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{size.tsv}
    \caption{Efficiency for a varied packet size}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as packet size increases},
                xlabel={Packet size (\textit{byte})},
                xmin=0, xmax=4096, xtick distance=1024,
                ylabel={Efficiency},
                ymin=0.3, ymax=0.8,
                legend pos=south east
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=PS, y=S] {size.tsv};
            \legend{S(FER, a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\end{document}
