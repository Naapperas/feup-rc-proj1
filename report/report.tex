\documentclass[11pt,a4paper,twocolumn]{article}

\usepackage[margin=.75in]{geometry}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage[super]{nth}
\usepackage{siunitx}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.18}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orange}{rgb}{.7,.3,0}

\makeatletter
\lst@InstallKeywords k{types}{typestyle}\slshape{typestyle}{}ld
\makeatother

\lstset{
    language=c,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    basicstyle={\small\ttfamily},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    typestyle=\color{orange},
    breaklines=true,
    breakatwhitespace=true,
    moretypes={
        LLConnection, LLConnectionParams, LLRole, Frame, ByteVector,
        uint8_t, size_t, ssize_t, bool, termios, timer_t
    }
}

\title{RC - \nth{1} Project}
\author{Jo√£o Pereira, Nuno Pereira}

\begin{document}

\maketitle

% \begin{abstract}
%     TODO
% \end{abstract}

% \pagebreak

% \tableofcontents

% \pagebreak

\section{Introduction}

The objective of this project was to develop a simple data link layer and an application to test the effectiveness of this layer.

\section{Architecture}

\subsection{Layers}

The code was divided into two distinct layers. This has the advantage of making the code more modular, reusable and versatile, as either layer could be swapped for another with a similar interface with minimal effort.

\subsubsection{Data Link Layer}

This is the lower level layer, it interfaces with the serial port driver directly. It is responsible for ensuring the data gets sent and received.

\subsubsection{Application Layer}

This is the higher level layer, it interfaces with the data link layer and with the file system. It is responsible for reading a file, breaking it up into chunks, sending these chunks through the data link layer, receiving these chunks, and assembling them back into a file.

\subsection{Program Execution}

The program can be executed by calling \lstinline{app serial_port role file_name}, where:

\begin{itemize}
    \item \lstinline{app} is the program executable;
    \item \lstinline{serial_port} is the serial port file path;
    \item \lstinline{role} is one of \lstinline{rx|tx}, for receiving or transmitting a file, respectively;
    \item \lstinline{file_name} is the path of the file to be sent.
\end{itemize}

\section{Code Structure}

\subsection{Data Link Layer}
\label{sec:dll}

The Data Link Layer is centered on the \lstinline{link_layer.c} file and the \lstinline{link_layer} folder.
The \lstinline{link_layer.c} file contains the protocol interface that can be used by upper layers, the \lstinline{timer.c} file contains code related to interfacing with POSIX timers, and the \lstinline{frame.c} file contains code to create and manipulate frames.

\subsubsection{link\_layer.c}

\begin{itemize}
    \item \begin{lstlisting}
typedef enum { LL_TX, LL_RX } LLRole;
    \end{lstlisting}

          Defines the role of a link layer connection.

    \item \begin{lstlisting}
typedef struct {
    char serial_port[50];
    LLRole role;
    int baud_rate;
    int n_retransmissions;
    int timeout;
} LLConnectionParams;
    \end{lstlisting}

          Defines the parameters required to create a new link layer connection.

    \item \begin{lstlisting}
struct _LLConnection {
    LLConnectionParams params;
    struct termios old_termios;
    int fd;
    bool closed;
    uint8_t tx_sequence_nr;
    uint8_t rx_sequence_nr;
    int n_retransmissions_sent;
    timer_t timer;
    Frame *last_command_frame;
};
    \end{lstlisting}

          Defines the state of a link layer connection.

    \item \begin{lstlisting}
LLConnection *llopen(
    LLConnectionParams params);
    \end{lstlisting}

          Opens a new link layer connection and returns it.

    \item \begin{lstlisting}
ssize_t llwrite(
    LLConnection *connection,
    const uint8_t *buf,
    size_t buf_len);
    \end{lstlisting}

          Sends data through a connection.

    \item \begin{lstlisting}
ssize_t llread(
    LLConnection *connection, 
    uint8_t *buf);
    \end{lstlisting}

          Reads data from a connection.

    \item \begin{lstlisting}
int llclose(
    LLConnection *connection, 
    bool show_stats);
    \end{lstlisting}

          Closes a connection.
\end{itemize}

\subsubsection{link\_layer/timer.c}

\begin{itemize}
    \item \begin{lstlisting}
void timer_setup(
    LLConnection *connection);
    \end{lstlisting}

          Sets up a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_destroy(
    LLConnection *connection);
    \end{lstlisting}

          Deallocates a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_arm(
    LLConnection *connection);
    \end{lstlisting}

          Starts a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_disarm(
    LLConnection *connection);
    \end{lstlisting}

          Stops a connection's POSIX timer.

    \item \begin{lstlisting}
void timer_force(
    LLConnection *connection);
    \end{lstlisting}

          Forcibly calls a connection's timer handler.

\end{itemize}

\subsubsection{link\_layer/frame.c}

\begin{itemize}
    \item \begin{lstlisting}
typedef struct {
    uint8_t address;
    uint8_t command;
    ByteVector *information;
} Frame;
    \end{lstlisting}

          Defines all the data needed to represent a frame.

    \item \begin{lstlisting}
Frame *create_frame(
    LLConnection *connection, 
    uint8_t cmd);
    \end{lstlisting}

          Creates a new frame.

    \item \begin{lstlisting}
Frame *read_frame(
    LLConnection *connection);
    \end{lstlisting}

          Reads a frame from the connection's serial port.

    \item \begin{lstlisting}
ssize_t write_frame(
    LLConnection *connection, 
    Frame *frame);
    \end{lstlisting}

          Writes a frame to the connection's serial port.

    \item \begin{lstlisting}
void frame_destroy(Frame *this);
    \end{lstlisting}

          Deallocates all memory allocated by a frame.

    \item \begin{lstlisting}
ssize_t send_frame(
    LLConnection *connection, 
    Frame *frame);
    \end{lstlisting}

          Sends a frame to the connection's serial port and sets up retransmission if the frame is a command.

    \item \begin{lstlisting}
Frame *expect_frame(
    LLConnection *connection, 
    uint8_t command);
    \end{lstlisting}

          Receives frames from a connection until a certain command is received.

\end{itemize}

\subsection{Application Layer}

The Application Layer is centered around the \lstinline{application_layer.c} file and the \lstinline{application_layer} folder.
The \lstinline{application_layer.c} file contains the client facing interface of the application which is responsible for all the higher level setup and communication between transmitter and receiver.
The \lstinline{packet.c} file contains code that is responsible for correctly creating control and data packets.

\subsubsection{application\_layer.c}

\begin{itemize}
    \item \begin{lstlisting}
LLConnectionParams setupLLParams(
    const char *serial_port, 
    const char *role, 
    int baud_rate, 
    int nTries, 
    int timeout);
    \end{lstlisting}

          Compiles the parameters given to the application layer into an \lstinline{LLConnectionParams} object to be used by the underlying \hyperref[sec:dll]{Data Link Layer}.

    \item \begin{lstlisting}
LLConnection *connect(
    LLConnectionParams ll);
    \end{lstlisting}

          Opens a connection to one of the computer's serial ports.

    \item \begin{lstlisting}
int init_transmission(
    LLConnection *connection, 
    char *filename);
    \end{lstlisting}

          Starts the communication process between transmitter and receiver.

    \item \begin{lstlisting}
ssize_t receiver(
    LLConnection *connection);
    \end{lstlisting}

          Executes the receiver's operational flow.

    \item \begin{lstlisting}
ssize_t transmitter(
    LLConnection *connection, 
    const char *filename);
    \end{lstlisting}

          Executes the transmitter's operational flow.

    \item \begin{lstlisting}
void applicationLayer(
    const char *serial_port, 
    const char *role, 
    int baud_rate, 
    int n_tries, 
    int timeout, 
    const char *filename);
    \end{lstlisting}

          Entrypoint for the application layer.

\end{itemize}

\subsubsection{application\_layer/packet.c}

\begin{itemize}
    \item \begin{lstlisting}
ByteVector *create_start_packet(
    size_t file_size, 
    const char *file_name);
    \end{lstlisting}

          Creates a \textbf{START} packet containing the transmitted file's size and name.

\end{itemize}

\section{Main Use Cases}

There are two main use cases: either sending a file or receiving a file.
These use cases are described below.

\subsection{Sending a file}

TODO

\subsection{Receiving a file}

TODO

\section{Link Layer Protocol}

The link layer protocol's flow is as follows: open a connection using \lstinline{llopen}, send arbitrary data using \lstinline{llwrite}, receive arbitrary data using \lstinline{llread}, and close the connection using \lstinline{llclose}.
Each step's implementation is described below.

This implementation uses an \lstinline{LLConnection} struct to save the state of a connection and in theory allows multiple serial port connections to be open in a single process.
In practice this was not required or tested.

\subsection{llopen}

\begin{lstlisting}
LLConnection *llopen(
    LLConnectionParams params);
\end{lstlisting}

This function opens a connection to the serial port and creates a new Data Link Layer connection object.

Firstly, this functions calls \lstinline{setup_serial} to setup the serial port connection, then it calls \lstinline{timer_setup} to setup a POSIX timer to handle timeouts when sending commands.
Afterwards, the implementation differs depending on the role of a connection.

From a transmitter's standpoint, a connection can only be considered \textbf{open} when a receiver is ready to receive data.
As so, this function implements a syncing procedure and sends a \textit{SET} command, which must get a \textit{UA} response in return.
If a response is not received, the command is resent a configurable amount of times, with an also configurable amount of time between them.

On the other hand, a receiver's connection can be considered open immediately, which means this syncing procedure is not handled by this function.

\subsection{llwrite}

\begin{lstlisting}
ssize_t llwrite(
    LLConnection *connection, 
    const uint8_t *buf, 
    size_t buf_len);
\end{lstlisting}

This function sends some arbitrary data to the serial port.

To do this, first the function creates a new \lstinline{Frame} with an \textit{I} command, and fills its information vector with the data.
Afterwards it sends this frame by using the \lstinline{send_frame} function.

This function in turn calls \lstinline{write_frame}, which assembles the frame in a \lstinline{ByteVector} into the correct structure and byte order, after performing byte stuffing on its information.
It then writes the bytes in this vector to the serial port.

After sending the frame, a response of type \textit{RR} with the next sequence bit is expected by calling the \lstinline{expect_frame} function.
If this function does not get a response within the set timeout, a POSIX timer that was armed in the \lstinline{send_frame} function is triggered and sends the information frame again.
This repeats until the response arrives, after which the timer is disarmed and the amount of bytes sent is returned, or until a set maximum amount of retries is reached, after which the timer is also disarmed and -1 is returned, signaling an error.

\subsection{llread}

\begin{lstlisting}
ssize_t llread(
    LLConnection *connection, 
    uint8_t *buf);
\end{lstlisting}

This function reads some arbitrary data from the serial port.

To do this, first the function expects to receive a command of type \textit{I} with the next sequence bit by calling \lstinline{expect_frame}, this function, which is explained in more detail above, automatically sends the correct \textit{RR} response, disassembles the received frame and destuffs its information.

Afterwards the received data is copied to the provided buffer and its length is returned.
If some part of this process is unsuccessful -1 is returned, signaling an error.

\subsection{llclose}

\begin{lstlisting}
int llclose(
    LLConnection *connection, 
    bool show_stats);
\end{lstlisting}

This function closes a connection to the serial port and destroys all of its state.

To do this, first a syncing protocol is employed, so both layers close at roughly the same time.
In this protocol the transmitter sends a \textit{DISC} command, then receives a \textit{DISC} command, and then sends a \textit{UA} response.
The receiver does the same but reversed, receives a \textit{DISC} command, then sends a \textit{DISC} command, and then receives a \textit{UA} response.
This is implemented using a combination of the functions \lstinline{send_frame} and \lstinline{expect_frame}, which are explained in more detail above.

Afterwards \lstinline{connection_destroy} is called, deallocating all resources related to the connection and resetting the serial port settings to their original state.

\section{Application Layer Protocol}

The application layer protocol's flow is as follows:
open a connection to the other system using the \hyperref[sec:dll]{Data Link Layer},
open a descriptor to the file specified,
identify the file being transmitted,
read chunks of the file and send them through the \hyperref[sec:dll]{Data Link Layer},
signal the end of the transmission.

\section{Validation}

The application was tested in several circumstances:

\begin{itemize}
    \item Using different files: penguin.gif (\qty{10968}{\byte}), neuron.jpg (\qty{31802}{\byte}), test (\qty{9594624}{\byte});
    \item With temporary disconnects;
    \item With interference;
    \item Using different baud rates: \qtylist{9600;19200;38400;57600;115200}{baud};
    \item Using different packet sizes: \qtylist{16;32;64;128;256;512;1024;2048;4096}{\byte};
    \item Using different cable lengths (simulated in software using the benchmark of \qty[per-mode=symbol]{5}{\micro\second\per\kilo\metre}): \qtylist{0;1;5;10;50;100;500;1000;5000;10000}{\kilo\metre}
\end{itemize}

All tests were successful.
The received file's integrity was verified visually and by using \lstinline{diff}.

\section{Link Layer Efficiency}

The data link layer efficiency was tested mainly by varying a few parameters, namely the connection capacity, the frame error ratio (simulated), the cable length (simulated), and the packet size.
All of these tests are in \href{sec:a2}{Appendix 2}.

\subsection{Varying the Connection Capacity}

Varying the connection capacity resulted in an almost constant efficiency function (a slightly downwards slope linear function).

This makes sense from a theoretical standpoint, as the efficiency is calculated by dividing the real flow by the connection capacity, and the real flow is directly proportional to the connection capacity.

\subsection{Varying the Frame Error Ratio}

TODO

\subsection{Varying the Cable Length}

TODO

\subsection{Varying the Packet Size}

TODO

\section{Conclusions}

TODO

\onecolumn
\appendix
\section{Appendix}

\subsection{Code}

\noindent In folder \lstinline{code/}.

\subsection{Figures}
\label{sec:a2}

\pgfkeys{/pgf/number format/.cd,fixed,precision=4}
\pgfplotstableset{
    every head row/.style={before row=\hline},
    every last row/.style={after row=\hline},
    every column/.style={column type/.add={|}{}},
    every first column/.style={column type/.add={|}{}},
    every last column/.style={column type/.add={}{||}},
}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/C/.style={column name={Baud rate}},
        columns/FS/.style={column name={File size}},
        columns/PS/.style={column name={Packet size}},
        every first row/.style={
                before row={
                        \textit{bit/s} &
                        \textit{bit} &
                        \textit{byte} \\
                        \hline \hline}
            }
    ]{defaults.tsv}
    \caption{Default values}
\end{table}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/C/.style={column name={Baud rate}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        \textit{bit/s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{c.tsv}
    \caption{Efficiency for a varied baud rate}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as baud rate increases},
                xlabel={Baud rate (\textit{bit/s})},
                xmin=0, xmax=120000,
                ylabel={Efficiency},
                ymin=0.7, ymax=0.8
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=C, y=S] {c.tsv};
            \legend{S(FER; a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/FER/.style={column name={Frame error ratio}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{fer.tsv}
    \caption{Efficiency for a varied frame error ratio}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as frame error ratio increases},
                xlabel={Frame error ratio},
                xmin=0, xmax=.2,
                ylabel={Efficiency},
                ymin=0, ymax=1
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=FER, y=S] {fer.tsv};
            \legend{S(FER; a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/d/.style={column name={Cable length}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        \textit{km} &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{tprop.tsv}
    \caption{Efficiency for a varied cable length}
\end{table}

\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as cable length increases},
                xlabel={Cable length (\textit{km})},
                xmin=0, xmax=10000,
                ylabel={Efficiency},
                ymin=0.4, ymax=0.8
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=d, y=S] {tprop.tsv};
            \legend{S(FER; a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\begin{table}[h!]
    \centering
    \pgfplotstabletypeset[
        columns/PS/.style={column name={Packet size}},
        columns/t1/.style={column name={$t_1$}},
        columns/t2/.style={column name={$t_2$}},
        columns/t/.style={column name={$t_{mean}$}},
        columns/R/.style={column name={Flow}},
        columns/S/.style={column name={Efficiency}},
        every first row/.style={
                before row={
                        \textit{byte} &
                        \textit{s} &
                        \textit{s} &
                        \textit{s} &
                        \textit{bit/s} &
                        \\
                        \hline \hline}
            }
    ]{size.tsv}
    \caption{Efficiency for a varied packet size}
\end{table}

\pgfkeys{/pgf/number format/.cd,fixed,precision=0}
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
                title={Efficiency as packet size increases},
                xlabel={Packet size (\textit{byte})},
                xmin=0, xmax=4096, xtick distance=1024,
                ylabel={Efficiency},
                ymin=0.3, ymax=0.8,
                legend pos=south east
            ]
            \addplot[
                color=blue,
                mark=square
            ] table[x=PS, y=S] {size.tsv};
            \legend{S(FER; a)}
        \end{axis}
    \end{tikzpicture}
\end{center}

\end{document}
